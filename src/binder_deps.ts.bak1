import { prototypeOfClass } from "./struct.ts"
//import { CallableFunctionsOf, MethodsOf } from "./typedefs.ts"

export const
	bind_method_factory = <T, NAME extends keyof CallableFunctionsOf<T>, FN extends T[NAME] & (CallableFunction & ((this: T, ...args: any) => any))>(instance: T, method_name: NAME, ...args: Parameters<FN>) => ((thisArgs: T) => (instance[method_name] as FN).bind(thisArgs, ...args)) as ((thisArgs: T) => FN),
	array_proto = prototypeOfClass(Array),
	map_proto = prototypeOfClass(Map),
	set_proto = prototypeOfClass(Set),
	array_pop_bind: <T>(thisArg: Array<T>) => Array<T>["pop"] = /*@__PURE__*/ bind_factory(array_proto.pop),
	array_push_bind: <T>(thisArg: Array<T>) => Array<T>["push"] = /*@__PURE__*/ bind_factory(array_proto.push),
	array_splice_bind: <T>(thisArg: Array<T>) => Array<T>["splice"] = /*@__PURE__*/ bind_factory(array_proto.splice),
	array_clear_bind: <T>(thisArg: Array<T>) => Array<T>["splice"] = /*@__PURE__*/ bind_factory(array_proto.splice, 0),
	array_at_bind: <T>(thisArg: Array<T>) => Array<T>["at"] = /*@__PURE__*/ bind_factory(array_proto.at),
	stack_seek_bind: <T>(thisArg: Array<T>) => Array<T>["at"] = /*@__PURE__*/ bind_factory(array_proto.at, -1),
	map_get_bind: <K, V>(thisArg: Map<K, V>) => Map<K, V>["get"] = /*@__PURE__*/ bind_factory(map_proto.get),
	map_has_bind: <K, V>(thisArg: Map<K, V>) => Map<K, V>["has"] = /*@__PURE__*/ bind_factory(map_proto.has),
	map_set_bind: <K, V>(thisArg: Map<K, V>) => Map<K, V>["set"] = /*@__PURE__*/ bind_factory(map_proto.set),
	map_delete_bind: <K, V>(thisArg: Map<K, V>) => Map<K, V>["delete"] = /*@__PURE__*/ bind_factory(map_proto.delete),
	set_delete_bind: <T>(thisArg: Set<T>) => Set<T>["delete"] = /*@__PURE__*/ bind_factory(set_proto.delete),
	set_add_bind: <T>(thisArg: Set<T>) => Set<T>["add"] = /*@__PURE__*/ bind_factory(set_proto.add),
	set_has_bind: <T>(thisArg: Set<T>) => Set<T>["has"] = /*@__PURE__*/ bind_factory(set_proto.has)

export const
	bind_array_pop = bind_method_factory(array_proto, "pop")

/*
const _bind_method_factory = <T, NAME extends keyof T, FN extends T[NAME] & (CallableFunction & ((this: T, ...args: any) => any))>(
	instance: T,
	method_name: NAME,
	...partial_args: Parameters<FN>
) => {
	return <S extends T, A extends typeof partial_args, B extends any[], R>(thisArg: S) => {
		return (instance[method_name] as FN).bind<S, typeof partial_args, Parameters<FN>, ReturnType<FN>>(thisArg, ...partial_args)
	}
}
*/

const bind_method_fac = <
	T,
	M extends keyof T,
	A extends any[],
	B extends any[],
	R,
	FN extends T[M] & ((this: T, ...args: [...A, ...B]) => R),
>(instance: T, method_name: M, ...args: A): ((...args: B) => R) => {
	return (instance[method_name] as FN).bind<T, A, B, R>(instance, ...args)
}


const bind_method_fac2 = <
	T,
	A extends any[],
	B extends any[],
	R,
	FN extends ((this: T, ...args: [...A, ...B]) => R),
>(func: FN, ...args: A): ((...args: B) => R) => {
	return (func).bind<T, A, B, R>(Object.prototype as T, ...args)
}

/*
const bind_method_fac3 = <
	T,
	A extends any[],
	B extends any[],
	R,
	FN extends ((this: T, ...args: [...A, ...B]) => R)
>(
	func: FN & ((this: T, ...args: [...A, ...B]) => R),
	...args: A
) => (<S extends T>(thisArg: S) => func.bind<T, A, B, R>(thisArg, ...args))
*/

type BindableFunction<T, A extends any[], B extends any[], R> = ((this: T, ...args: [...A, ...B]) => R)

const bind_method_fac3 = <
	T,
	A extends any[],
	B extends any[],
	R,
>(
	func: BindableFunction<T, A, B, R>,
	...args: A
) => (<S extends T>(thisArg: S) => func.bind<T, A, B, R>(thisArg, ...args))

const bind_method_fac4 = <
	T,
	A extends any[],
	B extends any[],
	R,
	FN extends ((this: T, ...args: [...A, ...B]) => R) & CallableFunction,
	M extends keyof T & FN["name"],
>(
	instance: T,
	method_name: M,
	...args: A
) => bind_method_fac3<T, A, B, R>(instance[method_name] as FN, ...args)

type BindableFunctionFromName<T, NAME extends keyof T & (string | symbol), A extends any[], B extends any[], R> = BindableFunction<T[NAME], A, B, R>

let f: BindableFunctionName<Array<number>, "splice"> = Array.prototype.splice

type CallableFunctionsOf<T, A extends any[], B extends any[], R> = { [K in keyof T as (T[K] extends BindableFunction<T, A, B, R> ? K : never)]: T[K] }

const bind_method_fac5 = <
	T,
	M extends keyof T,
	FN extends (typeof instance)[typeof method_name] extends BindableFunction<T, any, any, any> ? BindableFunction<T, any, any, any> : never,
	A extends FN extends BindableFunction<T, infer P, any, any> ? P : never,
>(
	instance: T,
	method_name: M,
	...args: A
) => bind_method_fac3(instance[method_name] as FN, ...args)

const bind_method_fac6 = <
	T,
	M extends keyof T,
	FN extends (typeof instance)[typeof method_name] extends BindableFunction<T, any, any, any> ? BindableFunction<T, any, any, any> : never,
	A extends FN extends BindableFunction<T, infer P, any, any> ? P : never,
	B extends FN extends BindableFunction<T, any, infer P, any> ? P : never,
	R extends FN extends BindableFunction<T, any, any, infer P> ? P : never,
>(
	instance: T,
	method_name: M,
	...args: A
) => bind_method_fac3<T, A, B, R>(instance[method_name] as FN, ...args)

const bind_method_fac7 = <
	T,
	M extends keyof T,
	FN extends T[M] extends BindableFunction<T, any, any, any> ? BindableFunction<T, any, any, any> : never,
	B extends FN extends BindableFunction<T, any, infer P, any> ? P : never,
	R extends FN extends BindableFunction<T, any, any, infer P> ? P : never,
>(
	instance: T,
	method_name: M,
	...args: any[]
) => bind_method_fac3<T, typeof args, B, R>(instance[method_name] as FN, ...args)

const bind_method_fac8 = <
	T extends Record<M, BindableFunction<T, unknown[], unknown[], any>>,
	M extends PropertyKey,
	A extends (T[M] extends BindableFunction<T, infer P, unknown[], R> ? P : never),
	R extends ReturnType<T[M]>,
>(
	instance: T,
	method_name: M,
	...args: A
) => bind_method_fac3<T, A, (T[M] extends BindableFunction<T, A, infer B, R> ? B : never), R>(instance[method_name], ...args)


const bind_method_fac9 = <
	T extends Record<M, BindableFunction<T, unknown[], unknown[], any>>,
	M extends PropertyKey,
	A extends (T[M] extends BindableFunction<T, infer P, unknown[], R> ? P : never),
	R extends ReturnType<T[M]>,
>(
	instance: T,
	method_name: M,
	...args: A
) => (<
	S extends T,
	SB extends (S[M] extends BindableFunction<S, A, infer P, SR> ? P : never),
	SR extends ReturnType<S[M]>,
>(thisArg: S) => instance[method_name].bind<T, A, SB, SR>(thisArg, ...args)
)

const _bind_array_clear2 = bind_method_fac9(Map.prototype, "set")
const r = new Map<number, Set<number>>()
const c = _bind_array_clear2(r)
r.delete()

const _bind_method_factory = <T, NAME extends keyof T, FN extends T[NAME] & (CallableFunction & ((this: T, ...args: any) => any))>(
	instance: T,
	method_name: NAME,
	...partial_args: Parameters<FN>
) => {
	return <S extends T, A extends typeof partial_args, B extends any[], R>(thisArg: S) => {
		return (instance[method_name] as FN).bind<S, typeof partial_args, Parameters<FN>, ReturnType<FN>>(thisArg, ...partial_args)
	}
}

const _bind_array_clear = bind_method_fac3(Array.prototype.splice, 0)
const a = [1, 2, 3, 4]
const b = _bind_array_clear(a)

function myFunction(arg1: string, arg2: number): number {
	// do something
}

const myFunctionType = infer MyFunctionType


const
	instance = Array.prototype
let
	method_name: keyof CallableFunctionsOf<typeof instance, A, B, R>

) => bind_method_fac3(instance[method_name] as BindableFunction<T, A, B, R>, ...args)
