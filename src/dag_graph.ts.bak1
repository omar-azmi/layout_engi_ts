interface Vertex<K extends keyof any, V> {
	id: K
	data: V
}

interface DirectedEdge<K extends keyof any> {
	from: K
	to: K
}

interface AdjacentVertex<K extends keyof any> {
	id: K
	ins: Set<K>
	outs: Set<K>
}

type GraphNode<K extends keyof any, V> = Vertex<K, V> & AdjacentVertex<K>
type GraphNodeMapEntry<V> = Omit<Vertex<any, V> & AdjacentVertex<any>, "id">
type GraphNodesMap<K extends keyof any, V> = Map<K, GraphNodeMapEntry<V>>

const
	array_proto = Array.prototype,
	map_proto = Map.prototype,
	set_proto = Set.prototype,
	array_pop_bind = array_proto.pop.bind as <T>(thisArg: Array<T>) => Array<T>["pop"],
	array_push_bind = array_proto.push.bind as <T>(thisArg: Array<T>) => Array<T>["push"],
	map_get_bind = map_proto.get.bind as <K, V>(thisArg: Map<K, V>) => Map<K, V>["get"],
	map_has_bind = map_proto.has.bind as <K, V>(thisArg: Map<K, V>) => Map<K, V>["has"],
	map_set_bind = map_proto.set.bind as <K, V>(thisArg: Map<K, V>) => Map<K, V>["set"],
	map_delete_bind = map_proto.set.bind as <K, V>(thisArg: Map<K, V>) => Map<K, V>["delete"],
	set_add_bind = set_proto.add.bind as <T>(thisArg: Set<T>) => Set<T>["add"],
	set_has_bind = set_proto.has.bind as <T>(thisArg: Set<T>) => Set<T>["has"],
	set_delete_bind = set_proto.delete.bind as <T>(thisArg: Set<T>) => Set<T>["delete"]


interface DirectedAcyclicGraph<ID extends keyof any, DATA> {
	/** all nodes inside of this graph */
	nodes: GraphNodesMap<ID, DATA>
	/** get a node. */
	get: (id: ID) => GraphNodeMapEntry<DATA>
	/** check if a node exists. */
	has: (key: ID) => boolean
	/** set the value of a node. */
	set: (key: ID, value: GraphNodeMapEntry<DATA>) => Map<ID, GraphNodeMapEntry<DATA>>
	/** delete a node from `this.nodes`, in a primitive way */
	_delete_node: (key: ID) => boolean

	/** add a node. <br>
	 * @returns `false` if a node of the same `id` already exists, else a `true` will be returned.
	*/
	add: ({ id, ...rest }: GraphNode<ID, DATA>) => boolean

	/** delete a node, and destroy (unlink) all of its adjacent connections <br>
	 * @returns `false` if a node of the provided `id` does not exist, else a `true` will be returned.
	*/
	delete: (id: ID) => boolean

	/** create a directed edge connection from a node of id `from` to a node of id `to`. <br>
	 * does not check for two way connection, which shouldn't happen in a DAG.
	 * @returns `false` if a connection already exists, else a `true` will be returned.
	*/
	link: (from: ID, to: ID) => boolean

	/** destroy a directed edge connection from a node of id `from` to a node of id `to`. <br>
	 * does not check for two way connection, which shouldn't happen in a DAG.
	 * @returns `false` if a connection did not already exists between the two nodes, else a `true` will be returned.
	*/
	unlink: (from: ID, to: ID) => boolean

	/** get a sequence of nodes ordered according to their dependency (aka topologically sorted). <br>
	 * nodes with the least amount of dependency wil come first, while those with the most dependencies will end last. <br>
	 * traversing a topologically ordered sequence of nodes guarantees you that you always previously encounter any possible dependency of the current node. <br>
	*/
	topologicalOrder: () => ID[]
}

const DirectedAcyclicGraph = class <ID extends keyof any, DATA> implements DirectedAcyclicGraph<ID, DATA> {
	nodes: GraphNodesMap<ID, DATA> = new Map()

	constructor() { }

	get = map_get_bind(this.nodes) as (id: ID) => GraphNodeMapEntry<DATA>
	has = map_has_bind(this.nodes)
	set = map_set_bind(this.nodes)
	_delete_node = map_delete_bind(this.nodes)

	add = ({ id, ...rest }: GraphNode<ID, DATA>): boolean => {
		if (this.has(id)) { return false }
		this.set(id, rest)
		return true
	}

	delete = (id: ID): boolean => {
		const { has, get, _delete_node } = this
		if (!has(id)) { return false }
		const { ins, outs } = get(id)!
		for (const from_id of ins as Set<ID>) { get(from_id)!.outs.delete(id) }
		for (const to_id of outs as Set<ID>) { get(to_id)!.ins.delete(id) }
		ins.clear()
		outs.clear()
		_delete_node(id)
		return true
	}

	link = (from: ID, to: ID): boolean => {
		const
			get = this.get,
			from_node_outs = get(from)!.outs
		if (from_node_outs.has(to)) { return false }
		from_node_outs.add(to)
		get(to)!.ins.add(from)
		return true
	}

	unlink = (from: ID, to: ID): boolean => {
		const
			get = this.get,
			from_node_outs = get(from)!.outs
		if (!from_node_outs.has(to)) { return false }
		from_node_outs.delete(to)
		get(to)!.ins.delete(from)
		return true
	}

	topologicalOrder = (): ID[] => {
		const
			unvisited_id_stack: ID[] = [],
			pop_unvisited_id_stack: () => ID | undefined = array_pop_bind(unvisited_id_stack),
			push_unvisited_id_stack = array_push_bind(unvisited_id_stack),
			visited: Set<ID> = new Set(),
			has_visited = set_has_bind(visited),
			add_visited = set_add_bind(visited),
			result: ID[] = [],
			push_result = array_push_bind(result),
			{ nodes, get } = this
		for (const [id, { ins }] of nodes) {
			if (ins.size === 0) { push_unvisited_id_stack(id) }
		}
		let id: ID
		while ((id = pop_unvisited_id_stack() as ID) !== undefined) {
			if (!has_visited(id)) {
				add_visited(id)
				push_result(id)
				for (const out_id of get(id).outs) {
					if (!has_visited(out_id)) { push_unvisited_id_stack(out_id) }
				}
			}
		}
		return result
	}
}

let G = new DirectedAcyclicGraph()

