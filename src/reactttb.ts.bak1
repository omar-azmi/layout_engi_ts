type StateID = number
type MemoID = number
type EffectID = number
type ObserverID = MemoID | EffectID
type NotifierID = StateID | MemoID
type Accessor<T> = (observer_id?: ObserverID) => T
type Setter<T> = (value: T) => void
type AccessorSetter<T> = [Accessor<T>, Setter<T>]

class State<T> {
	obvs: Set<ObserverID> = new Set()

	constructor(
		public value: T,
		public ctx: SignalContext,
		public id: StateID,
	) { }

	setValue: Setter<T> = (value) => {
		this.value = value
		this.ctx.notify(this.obvs)
	}

	getValue: Accessor<T> = (observer_id) => {
		if (observer_id) { this.obvs.add(observer_id) }
		return this.value
	}
}

type MemoFn<T> = (observer_id: ObserverID) => T

class Memo<T> {
	value?: T
	dirty: boolean
	obvs: Set<ObserverID> = new Set()

	constructor(
		public fn: MemoFn<T>,
		public ctx: SignalContext,
		public id: MemoID,
	) {
		this.dirty = true
	}

	updateValue(): void {
		this.value = this.fn(this.id)
		this.dirty = false
	}

	getValue = (observer_id?: ObserverID): T => {
		if (observer_id) { this.obvs.add(observer_id) }
		if (this.dirty) { this.updateValue() }
		return this.value!
	}
}

type SignalID = number
type Signal<T> = State<T> | Memo<T>

class SignalContext {
	id_counter: SignalID = 0
	signals: Map<SignalID, Signal<any>> = new Map()

	constructor() { }

	/** notify a set of observers to turn dirty */
	notify = (observers: Set<ObserverID>) => {
		const { signals } = this
		for (const id of observers) {
			const obv = signals.get(id) as Memo<any>
			if (!obv.dirty) {
				obv.dirty = true
				this.notify(obv.obvs)
			}
		}
	}

	createState = <T>(initial_value: T): AccessorSetter<T> => {
		const
			state_id = this.id_counter++,
			state = new State<T>(initial_value, this, state_id)
		this.signals.set(state_id, state)
		return [state.getValue, state.setValue]
	}

	createMemo = <T>(fn: MemoFn<T>): Accessor<T> => {
		const
			memo_id = this.id_counter++,
			memo = new Memo<T>(fn, this, memo_id)
		this.signals.set(memo_id, memo)
		return memo.getValue
	}
}

// Example usage
const { createState, createMemo } = new SignalContext()

const [s1, setS1] = createState<number>(1)
const [s2, setS2] = createState<number>(2)

const m1 = createMemo((id) => s1(id) * 2)
const m2 = createMemo((id) => s2(id) + m1(id))

console.log(get_counter, update_counter)
console.log(m2()) // Should output 0, as it's not computed yet
console.log(get_counter, update_counter)
setS1(3)
console.log(get_counter, update_counter)
setS2(10)
console.log(m2()) // Should output 13 after re-evaluation of dependencies
console.log(get_counter, update_counter)
