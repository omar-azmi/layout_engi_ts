// LTRB position = a signal
import { Accessor, ConstructorOf, MethodsOf, Setter, Signal, SignalOptions, createEffect, max, min, createSignal, createMemo, untrack } from "./deps.ts"
type Position = Accessor<DimensionXNumber & DimensionYNumber>

type AnyNumber = number | Accessor<number>

interface FrameSplitInit {
	id?: number
	name?: string
	margin?: DimensionConfig
	children?: FrameSplit[]
}

interface DimensionXNumber {
	left?: number
	right?: number
}
interface DimensionYNumber {
	top?: number
	bottom?: number
}
type Dirtyable = { dirty?: boolean }
type DimensionConfig = DimensionXNumber & DimensionYNumber
type DimensionValue = Required<DimensionConfig> & Dirtyable
type DimensionGetter = Accessor<DimensionValue>
type DimensionBaseSetter = Setter<DimensionConfig>
type DimensionSetter = (value: DimensionConfig) => DimensionValue
type SizeGetter = { width?: Accessor<number>, height?: Accessor<number> }
type SizeSetter = { width?: Setter<number>, height?: Setter<number> }

const ltrb_iter = ["left", "top", "right", "bottom"] as const

const createSignalIfPrimitive = (value: AnyNumber): [get: Accessor<number>, set?: Setter<number>] => {
	return typeof value === "number" ?
		createSignal(value) :
		[value, undefined]
}

const dimension_equality = (prev: DimensionValue, next: DimensionValue): boolean => {
	if (prev.dirty === false) { return true }
	prev.dirty = false
	return false
}

const dimension_partial_setter = (next: DimensionConfig) => (prev: DimensionValue): DimensionValue => {
	let i = 0
	let dirty = false
	for (let dim = ltrb_iter[i]; i < 4; dim = ltrb_iter[i]) {
		if (next[dim] !== undefined && prev[dim] !== next[dim]) {
			prev[dim] = next[dim] as number
			dirty = true
		}
		i++
	}
	prev.dirty = dirty
	return prev
}

const [gitter, s] = createSignal<Required<FrameDimension>>({
	left: 0, top: 0, right: 0, bottom: 0,
}, { equals: dimension_equality })
const sitter = (next: Partial<FrameDimension>) => s(dimension_partial_setter(next))
sitter({ left: -30, bottom: 800 })

createEffect(() => {
	console.log("UPDATED", gitter())
})


class FrameSplit {
	position: DimensionGetter
	setPosition: DimensionSetter
	size: SizeGetter = {}
	setSize: SizeSetter = {}
	margin: DimensionGetter
	setMargin: DimensionSetter
	getUpdate: Accessor<0>
	setUpdate: Setter<0>

	static id_count: number = 0
	id: number
	name?: string
	children: FrameSplit[]

	getFreespaceChild = (): FrameSplit => {
		const
			{ children } = this,
			len = children.length
		if (len > 0) { return children[0] }
		const
			{ left, top, right, bottom } = this.position,
			freespace_child = new FrameSplit(left, top, right, bottom)
		children.push(freespace_child)
		return freespace_child
	}

	constructor(
		left: AnyNumber,
		top: AnyNumber,
		right: AnyNumber,
		bottom: AnyNumber,
		{
			id = FrameSplit.id_count++,
			name = "",
			margin = {},
			children = [],
		}: FrameSplitInit = {},
	) {
		const
			ltrb = [left, top, right, bottom],
			position: DimensionsGetter = {},
			setPosition: DimensionsSetter = {},
			[getUpdate, setUpdate] = createSignal(0 as const, { equals: false })
		for (let i = 0; i < 4; i++) {
			const
				dim_name = ltrb_iter[i],
				dim = ltrb[i],
				[dim_getter, dim_setter] = createSignalIfPrimitive(dim)
			position[dim_name] = dim_getter
			setPosition[dim_name] = dim_setter
		}
		this.position = position as Required<typeof position>
		this.setPosition = setPosition
		this.getUpdate = getUpdate
		this.setUpdate = setUpdate
		this.margin = margin
		this.id = id
		this.name = name
		this.children = children
	}

	splitLeftChild = (
		width: AnyNumber,
		margin: MarginConfig = {},
	): FrameSplit => {
		const
			{ getFreespaceChild, children } = this,
			freespace = getFreespaceChild(),
			{ left, top, right, bottom } = freespace.position,
			[getWidth, setWidth] = createSignalIfPrimitive(width),
			[getUpdate, setUpdate] = createSignal(0 as const, { equals: false })
		const
			child_left = margin.left === undefined ? left : createMemo(() => min(
				left() + (margin.left ?? 0),
				right() - (margin.right ?? 0)
			) + getUpdate()),
			child_top = margin.top === undefined ? top : createMemo(() => min(
				top() + (margin.top ?? 0),
				bottom() - (margin.bottom ?? 0)
			) + getUpdate()),
			child_top = margin.top === undefined ? top : createMemo(() => top() + (margin.top ?? 0)),
			child_top = margin.top === undefined ? top : createMemo(() => top() + (margin.top ?? 0)),
			new_left = createMemo(() => min(left() + getWidth(), right() - getMargin())),
			child_framesplit = new FrameSplit(left, top, new_left, bottom)
		child_framesplit.rightMargin = getMargin
		child_framesplit.setRight = setWidth
		child_framesplit.setRightMargin = setMargin
		freespace.left = createMemo(() => min(new_left() + getMargin(), right()))
		children.push(child_framesplit)
		return child_framesplit
	}

	splitTopChild = (value: AnyNumber, margin: AnyNumber = 0): FrameSplit => {
		const
			{ getFreespaceChild, children } = this,
			freespace = getFreespaceChild(),
			{ left, top, right, bottom } = freespace,
			[getValue, setValue] = createSignalIfPrimitive(value),
			[getMargin, setMargin] = createSignalIfPrimitive(margin),
			new_top = createMemo(() => min(top() + getValue(), bottom() - getMargin())),
			child_framesplit = new FrameSplit(left, top, right, new_top)
		child_framesplit.bottomMargin = getMargin
		child_framesplit.setBottom = setValue
		child_framesplit.setBottomMargin = setMargin
		freespace.top = createMemo(() => min(new_top() + getMargin(), bottom()))
		children.push(child_framesplit)
		return child_framesplit
	}

	splitRightChild = (value: AnyNumber, margin: AnyNumber = 0): FrameSplit => {
		const
			{ getFreespaceChild, children } = this,
			freespace = getFreespaceChild(),
			{ left, top, right, bottom } = freespace,
			[getValue, setValue] = createSignalIfPrimitive(value),
			[getMargin, setMargin] = createSignalIfPrimitive(margin),
			new_right = createMemo(() => max(right() - getValue(), left() + getMargin())),
			child_framesplit = new FrameSplit(new_right, top, right, bottom)
		child_framesplit.leftMargin = getMargin
		child_framesplit.setLeft = setValue
		child_framesplit.setLeftMargin = setMargin
		freespace.right = createMemo(() => max(new_right() - getMargin(), left()))
		children.push(child_framesplit)
		return child_framesplit
	}

	splitBottomChild = (value: AnyNumber, margin: AnyNumber = 0): FrameSplit => {
		const
			{ getFreespaceChild, children } = this,
			freespace = getFreespaceChild(),
			{ left, top, right, bottom } = freespace,
			[getValue, setValue] = createSignalIfPrimitive(value),
			[getMargin, setMargin] = createSignalIfPrimitive(margin),
			new_bottom = createMemo(() => max(bottom() - getValue(), top() + getMargin())),
			child_framesplit = new FrameSplit(left, new_bottom, right, bottom)
		child_framesplit.topMargin = getMargin
		child_framesplit.setTop = setValue
		child_framesplit.setTopMargin = setMargin
		freespace.bottom = createMemo(() => max(new_bottom() - getMargin(), top()))
		children.push(child_framesplit)
		return child_framesplit
	}

	toString = () => untrack(() => {
		const {
			left, top, right, bottom,
			leftMargin, topMargin, rightMargin, bottomMargin,
			id, children
		} = this
		return {
			id,
			children_count: children.length,
			frame: {
				left: left(),
				top: top(),
				right: right(),
				bottom: bottom(),
			},
			margin: {
				left: leftMargin ? leftMargin() : undefined,
				top: topMargin ? topMargin() : undefined,
				right: rightMargin ? rightMargin() : undefined,
				bottom: bottomMargin ? bottomMargin() : undefined,
			},
			setters: Object.getOwnPropertyNames(this).filter((prop) => (prop.startsWith("set") && this[prop as keyof this] !== undefined))
		}
	})

	freespaceToString = () => {
		if (this.children.length > 0) { return this.children[0].toString() }
		return this.toString()
	}
}


const layout = new FrameSplit(0, 20, 200, 80)
layout.splitLeftChild(80, 5)
layout.splitRightChild(50).splitTopChild(50, 10)
layout.splitBottomChild(10, 10)
