const enum NODE_TYPE {
	STATE = 0,
	LAZY = 1,
	MEMO = 2,
	EFFECT = 3,
}
const NODE_TYPE_LEN = 4 as const
type StateID = NODE_TYPE.STATE | number
type LazyID = NODE_TYPE.LAZY | number
type MemoID = NODE_TYPE.MEMO | number
type EffectID = NODE_TYPE.EFFECT | number
type SignalerID = StateID | LazyID | MemoID
type ObserverID = LazyID | MemoID | EffectID
type NodeID = SignalerID | ObserverID

type UInt = number

const
	// the observers (values) of each signaler node (keys).
	// the observers' ids are guaranteed to be sorted in the order of their scheduled execution (as defined by `scheduled_observers`)
	signal_observers: Map<SignalerID, ObserverID[]> = new Map(),
	// scheduled nodes are ordered according to their topological ordering (look it up on wikipedia).
	// meaning that that when traversing `scheduled_observers`, you are guaranteed to have always previously encountered any dependency of the current node id.
	scheduled_observers: ObserverID[] = []

const schedule_new_observer = (id: ObserverID, dependencies: NodeID[]) => {
	// effect type nodes cannot have observers in the future, thus we need only to push it to the end of the scheduler list
	if (id % NODE_TYPE_LEN === NODE_TYPE.EFFECT) {
		scheduled_observers.push(id)
		return
	}
	const
		// we are only interested in dependencies that too can have other dependencies,
		// thus state kind dependencies don't matter for the scheduler,
		// because they themselves are always executed dependency free
		nonstate_dependencies: Set<ObserverID> = new Set(
			dependencies.filter(
				(dep_id) => ((dep_id % NODE_TYPE_LEN) > (0 as NODE_TYPE.STATE))
			)
		),
		len = scheduled_observers.length
	let insertion_index = 0 // the index at which our `id` will be inserted into the scheduler after the for loop
	// what the loop does: keep traversing `scheduled_observers` until all dependancies have been encounter.
	// after which, we would know where exactly to insert our `id` to
	for (; nonstate_dependencies.size > 0 && insertion_index < len; insertion_index++) {
		const node_id = scheduled_observers[insertion_index]
		if (nonstate_dependencies.has(node_id)) {
			nonstate_dependencies.delete(node_id)
		}
	}
	scheduled_observers.splice(insertion_index, 0, id)
}

/** add an observer's id to a signal's list of observers (`signal_observers[signal_id]`),
 * such that it maintains the order of their scheduled execution.
 * note that `observer_id` must already be registered to `scheduled_observers`.
*/
const insert_observer_to_signal = (signal_id: SignalerID, observer_id: ObserverID) => {
	const
		observer_ids = signal_observers.get(signal_id)!,
		len = observer_ids.length
	// making sure that the new `observer_id` hasn't been registered before
	if (observer_ids.includes(observer_id)) { return }
	const observer_pos = scheduled_observers.indexOf(observer_id)
	let i = 0
	for (let prev_index = 0; i < len; i++) {
		prev_index = scheduled_observers.indexOf(observer_ids[i], prev_index)
		if (prev_index > observer_pos) { break }
	}
	observer_ids.splice(i, 0, observer_id)
}

let id_counter: StateID = -NODE_TYPE_LEN
const
	all_nodes: Map<NodeID, Node<any>> = new Map(),
	increment_id_counter = () => (id_counter += 4),
	queued_reruns: Set<ObserverID> = new Set() // sets maintain the order of insertion when iterated, which is a property that we need for the reactions to run based on their scheduled order

const run_reactions_old = (signaler_id: SignalerID) => {
	for (const observer_id of signal_observers.get(signaler_id)!) {
		// since `observer_id`s appear in their scheduled execution order (thanks to `insert_observer_to_signal`),
		// we can just queue them for execution without worying about their order
		queued_reruns.add(observer_id)
	}
	for (const observer_id of queued_reruns) {
		all_nodes.get(observer_id)!.run()
		queued_reruns.add(4)
	}
	queued_reruns.clear() // any effect that should have avalanched would have done so by now, because the `for of` iterator accepts mutations on sets while it's iterating.
}

const queue_reactions = (signaler_id: SignalerID) => {
	queued_reruns.add(signaler_id)
	for (const node_id of queued_reruns) {
		for (const observer_id of signal_observers.get(node_id)!) {
			// since `observer_id`s appear in their scheduled execution order (thanks to `insert_observer_to_signal`),
			// we can just queue them for execution without worying about their order
			queued_reruns.add(observer_id)
		}
		all_nodes.get(node_id)!.run()
		queued_reruns.add(4)
	}
}

/*
const run_reactions = (signaler_id: SignalerID, prev_observer_index = 0) => {
	//let prev_observer_index = 0
	const
		observer_scheduled_index: number[] = [],
		observer_ids = signal_observers.get(signaler_id)!
	for (const observer_id of observer_ids) {
		const
			observer_is_effect = observer_id % NODE_TYPE_LEN === 3,
			// effect type nodes are at the end of the scheduler, thus we speed up their search by looking in the reverse direction
			observer_index = observer_is_effect ?
				scheduled_observers.lastIndexOf(observer_id as NODE_TYPE.EFFECT) :
				scheduled_observers.indexOf(observer_id as (NODE_TYPE.LAZY | NODE_TYPE.MEMO), prev_observer_index)
		observer_scheduled_index.push(observer_index)
		//prev_observer_index = observer_index
	}
	observer_scheduled_index.sort()

	queued_reruns.add()
	all_nodes.get(observer_id).run()
}
*/




//test


const mid = /* @__PURE__ */ (base: number) => (base * NODE_TYPE_LEN + 2)
schedule_new_observer(mid(0), [])
schedule_new_observer(mid(1), [mid(0)])
schedule_new_observer(mid(3), [mid(0)])
schedule_new_observer(mid(2), [mid(1), mid(3)])
schedule_new_observer(mid(4), [mid(2)])

console.log(scheduled_observers.map((v) => (v - 2) / NODE_TYPE_LEN))
