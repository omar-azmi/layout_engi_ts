type MemoID = number
type EffectID = number
type ObserverID = MemoID | EffectID
type Accessor<T> = (observer_id?: ObserverID) => T
type Setter<T> = (value: T) => void
type AccessorSetter<T> = [Accessor<T>, Setter<T>]
type MemoFn<T> = (observer_id?: ObserverID) => T
type EffectFn = (observer_id?: ObserverID) => void

/** type definition for a value equality check function. */
export type EqualityFn<T> = (prev_value: T, new_value: T) => boolean

/** type definition for an equality check specification. <br>
 * when `undefined`, javascript's regular `===` equality will be used. <br>
 * when `false`, equality will always be evaluated to false, meaning that setting any value will always fire a signal, even if it's equal.
*/
export type EqualityCheck<T> = undefined | false | EqualityFn<T>


export interface Signal<T> {
	obvs: Set<ObserverID>
	value: T
	equals: EqualityFn<T>
	set: Setter<T>
	get: Accessor<T>
}

/** represents options when creating a signal via {@link createSignal}. */
export interface CreateSignalOptions<T> {
	/** when a signal's value is updated through a {@link Setter}, then the dependants/observers of
	 * THIS signal will only be notified if the equality check function evaluates to a `false`. <br>
	 * see {@link EqualityCheck} to see its function signature and default behavior when left `undefined`
	*/
	equals?: EqualityCheck<T>
}

export interface Memo<T> {
	fn: MemoFn<T>
	dirty: boolean
	obvs: Set<ObserverID>
	value?: T
	id?: MemoID
	equals: EqualityFn<T>
	get: Accessor<T>
}

/** represents options when creating a memo via {@link createMemo}. */
export interface CreateMemoOptions<T> {
	/** when a memo's value is updated through a notification by its one of its dependancy `Signal`s or `Memo`s,
	 * then the dependants/observers of THIS memo will only be notified if the equality check function evaluates to a `false`. <br>
	 * see {@link EqualityCheck} to see its function signature and default behavior when left `undefined`
	*/
	equals?: EqualityCheck<T>
}

export interface Effect {
	fn: EffectFn
	id?: EffectID
	run: Accessor<void>
}

/** represents options when creating an effect signal via {@link createEffect}. */
export interface CreateEffectOptions {
	/** when `true`, the effect function {@link EffectFn} will not be run immediately (ie the first execution will be skipped),
	 * and its execution will be put off until one of its dependancy `Signal`'s or `Memo`'s value is updated. <br>
	 * by default, `defer` is `false`, and effects are immediately executed during initialization. <br>
	 * the reason why you might want to defer an effect is because the body of the effect function may contain symbols/variables
	 * that have not been defined yet, in which case an error will be raised, unless you choose to defer the first execution. <br>
	*/
	defer?: boolean
}

let get_counter = 0, update_counter = 0

const default_equality = (<T>(v1: T, v2: T) => (v1 === v2)) satisfies EqualityFn<any>
const falsey_equality = (<T>(v1: T, v2: T) => false) satisfies EqualityFn<any>

const createContext = () => {
	const
		memos_and_effects: Map<ObserverID, Effect | Memo<any>> = new Map(),
		effects_to_rerun: Set<EffectID> = new Set()
	let
		memo_id_counter: MemoID = 1,
		effect_id_counter: MemoID = -1

	/** notify a set of observers to turn dirty */
	const notify = (observers: Set<ObserverID>) => {
		for (const id of observers) {
			if ((id as MemoID) > 0) {
				const obv = memos_and_effects.get(id) as Memo<any>
				if (!obv.dirty) {
					obv.dirty = true
					notify(obv.obvs)
				}
			} else if ((id as EffectID) < 0) {
				effects_to_rerun.add(id)
			}
		}
	}

	const run_effects = () => {
		for (const effect_id of effects_to_rerun) {
			(memos_and_effects.get(effect_id) as Effect).run()
		}
		effects_to_rerun.clear()
	}

	const Signal = class <T> implements Signal<T>{
		obvs: Set<ObserverID> = new Set()
		equals: EqualityFn<T>

		constructor(
			public value: T,
			equals?: EqualityCheck<T>,
		) {
			this.equals = equals === false ? falsey_equality : (equals ?? default_equality)
		}

		set: Setter<T> = (value) => {
			if (this.equals(this.value, value)) { return }
			this.value = value
			notify(this.obvs)
			run_effects()
		}

		get: Accessor<T> = (observer_id) => {
			get_counter++
			if (observer_id) { this.obvs.add(observer_id) }
			return this.value
		}
	}

	const Memo = class <T> implements Memo<T>{
		obvs: Set<ObserverID> = new Set()
		value?: T
		equals: EqualityFn<T>
		dirty: boolean

		constructor(
			public fn: MemoFn<T>,
			public id?: MemoID,
			equals?: EqualityCheck<T>,
		) {
			this.dirty = true
			// TODO: it is incredibly difficult to inform a Memo's observers that this Memo's old value === new value, thus the dirty flag that was notified previously by this Memo can be ignored after the fact.
			// thus, I'll implement a new kind of `Computed` signal which will support `equals`, but also fire its computation immediately (just like effects) after a notification cycle ends 
			this.equals = equals === false ? falsey_equality : (equals ?? default_equality)
		}

		get: Accessor<T> = (observer_id) => {
			if (observer_id) { this.obvs.add(observer_id) }
			if (this.dirty) {
				update_counter++
				this.value = this.fn(this.id)
				this.dirty = false
				// destoy `this.id`, because there's no longer a need to notify this memo's dependancy signals
				// and memos inside of `this.fn`, since they've been notified before (in the `this.value = this.fn(this.id)` line)
				this.id = undefined
			}
			return this.value!
		}
	}

	const Effect = class implements Effect {
		constructor(
			public fn: EffectFn,
			public id?: EffectID,
		) {
			effects_to_rerun.add(id!)
		}

		run = (): void => {
			this.fn(this.id)
			// destoy `this.id`, because there's no longer a need to notify this effects's dependancy signals and
			// memos inside of `this.fn`, since they've been notified before (in the `this.fn(this.id)` line)
			this.id = undefined
		}
	}

	const createSignal = <T>(initial_value: T): AccessorSetter<T> => {
		const signal = new Signal<T>(initial_value)
		return [signal.get, signal.set]
	}

	const createMemo = <T>(fn: MemoFn<T>): Accessor<T> => {
		const
			memo_id: MemoID = memo_id_counter++,
			memo = new Memo<T>(fn, memo_id)
		memos_and_effects.set(memo_id, memo)
		return memo.get
	}

	const createEffect = (fn: EffectFn): Accessor<void> => {
		const
			effect_id: EffectID = effect_id_counter--,
			effect = new Effect(fn, effect_id)
		memos_and_effects.set(effect_id, effect)
		return effect.run
	}

	return { createSignal, createMemo, createEffect }
}


// Example usage
const { createSignal, createMemo, createEffect } = createContext()

const [s1, setS1] = createSignal<number>(1)
const [s2, setS2] = createSignal<number>(2)

const m1 = createMemo((id) => s1(id) * 2)
const m2 = createMemo((id) => s2(id) + m1(id))

const e1 = createEffect((id) => {
	console.log(`I seek s1 and m2: ${s1(id)}, ${m2(id)}`)
})

console.log(get_counter, update_counter)
console.log(m2()) // Should output 0, as it's not computed yet
console.log(get_counter, update_counter)
setS1(3)
console.log(get_counter, update_counter)
setS2(10)
console.log(m2()) // Should output 13 after re-evaluation of dependencies
console.log(get_counter, update_counter)
